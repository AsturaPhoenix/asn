package ai.xng;

import java.io.Serializable;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import lombok.Getter;

import java.util.Random;

/**
 * A 1-dimensional mini RL unit meant for learning the threshold that should
 * serve as a coefficient for synapse connections.
 * 
 * This is roughly a 3-bin histogram fitted to an asymmetric normal
 * distribution. The tail bins start roughly 1 "standard deviation" away (each
 * side has its own "standard deviation"), and their relative weights roughly
 * determine the skew of the distribution. The mean of the generated values is
 * the threshold, which is maintained by lengthening the tail proportionally on
 * the less probable side.
 * 
 * These properties are important because:
 * <ul>
 * <li>The weighted average of samples added to this distribution should
 * estimate a parameter value.
 * <li>Adding samples on either side of the parameter should increase
 * exploration on that side of the parameter.
 * <li>All things equal, the samples generated by this distribution should not
 * themselves cause the threshold to migrate without external variation of
 * weights. (This goal is acheived by ensuring the threshold is the mean.)
 * <li>Lastly, all things equal, this distribution should converge as it adds
 * its own samples, barring external variation of weights or samples.
 * </ul>
 * 
 * To facilitate processing optimization, the tails are truncated.
 */
public class ThresholdDistribution implements Distribution, Serializable {
    private static final long serialVersionUID = -2101048901598646069L;
    /** Number of "standard deviations" to include on each side. */
    public static final float TRUNCATE_BEYOND = 3;
    public static final float SPREAD_FACTOR = .01f, DEFAULT_WEIGHT = 1;

    private final Random random;
    @Getter
    private float threshold, weightCommon, weightAbove, weightBelow;
    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);

    @Override
    public String toString() {
        lock.readLock().lock();
        try {
            return String.format("%.4g x [%.4g-%.4g] (%.2f: %.2f-%.2f-%.2f)", threshold, threshold - getLeftSpread(),
                    threshold + getRightSpread(), getBias(), weightBelow, weightCommon, weightAbove);
        } finally {
            lock.readLock().unlock();
        }
    }

    /**
     * A rough (anti-)skew metric ranging from [-1, 1], based on tail weights. (e.g.
     * negative bias corresponds to positive skew.)
     * 
     * A pure bias metric for a two-bin distribution with one bin on each side of
     * the threshold can be formulated as {@code 2 * weightAbove / (weightBelow +
     * weightAbove) - 1}. To accommodate the middle bin here, we effectively add
     * half of it to each tail bin.
     */
    public float getBias() {
        lock.readLock().lock();
        try {
            return weightCommon > 0 || weightAbove > 0 || weightBelow > 0
                    ? (weightCommon + 2 * weightAbove) / (weightCommon + weightBelow + weightAbove) - 1
                    : 0;
        } finally {
            lock.readLock().unlock();
        }
    }

    /**
     * A rough metric for the total weight of the distribution, calculated as the
     * sum of the middle bin weight with the average of the tail bin weights.
     */
    public float getWeight() {
        lock.readLock().lock();
        try {
            return weightCommon + (weightBelow + weightAbove) / 2;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float getMode() {
        return threshold;
    }

    public ThresholdDistribution() {
        this(0);
    }

    public ThresholdDistribution(final float threshold) {
        this(new Random(), threshold);
    }

    public ThresholdDistribution(final Random random, final float threshold) {
        this.random = random;
        set(threshold);
    }

    @Override
    public void set(final float value) {
        lock.writeLock().lock();
        try {
            threshold = value;
            weightCommon = DEFAULT_WEIGHT;
            weightAbove = 0;
            weightBelow = 0;
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * The rough half-spread of this curve. This spread is allocated to each side
     * based on the bias.
     */
    public float getSpread() {
        lock.readLock().lock();
        try {
            // This seems to work well, though I don't really know why. SPREAD_FACTOR should
            // be kept relatively small, and we do obviously want to reduce spread as weight
            // increases. Perhaps it has something to do with the relation between variance
            // and sample size.
            //
            // It may be possible to simplify the left and right spreads by expanding bias;
            // this may be a worthwhile investigation in the future.
            return SPREAD_FACTOR * (weightBelow + weightAbove) / (float) Math.sqrt(1 + weightCommon);
        } finally {
            lock.readLock().unlock();
        }
    }

    public float getLeftSpread() {
        lock.readLock().lock();
        try {
            return getSpread() * (1 + getBias()) / 2;
        } finally {
            lock.readLock().unlock();
        }
    }

    public float getRightSpread() {
        lock.readLock().lock();
        try {
            return getSpread() * (1 - getBias()) / 2;
        } finally {
            lock.readLock().unlock();
        }
    }

    private float asymmetricNormal(final float value, final float standardDeviation) {
        if (standardDeviation == 0) {
            return value == threshold ? 1 : 0;
        } else {
            final float x = (value - threshold) / standardDeviation;
            return (float) Math.exp(-x * x / 2);
        }
    }

    /**
     * A hand-wavy continuous curve that looks like a normal distribution but
     * doesn't really represent the PDF of this distribution. It is however useful
     * for weighting bin allotments, maybe.
     */
    private float relPdf(final float value) {
        return asymmetricNormal(value, value < threshold ? getLeftSpread() : getRightSpread());
    }

    @Override
    public void add(final float value, final float weight) {
        if (weight == 0)
            return;

        lock.writeLock().lock();
        try {
            final float inertia = getWeight();
            // I don't know why this "works". Perhaps it's just because it looks vaguely
            // like the CDF under each bin?
            final float relativeDensity = relPdf(value);

            if (weight > -inertia + 1) {
                threshold = (inertia * threshold + weight * value) / (inertia + weight);
            }

            weightCommon = Math.max(0, weightCommon + weight * (2 * relativeDensity - 1));
            weightBelow = Math.max(0, weightBelow + weight * (value < threshold ? 1 - 2 * relativeDensity : -1));
            weightAbove = Math.max(0, weightAbove + weight * (value > threshold ? 1 - 2 * relativeDensity : -1));
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public float getMin() {
        lock.readLock().lock();
        try {
            return threshold - getLeftSpread() * TRUNCATE_BEYOND;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float getMax() {
        lock.readLock().lock();
        try {
            return threshold + getRightSpread() * TRUNCATE_BEYOND;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float generate() {
        lock.readLock().lock();
        try {
            float value;
            if (random.nextFloat() >= (getBias() + 1) / 2) {
                value = threshold - (float) Math.abs(random.nextGaussian()) * getLeftSpread();
            } else {
                value = threshold + (float) Math.abs(random.nextGaussian()) * getRightSpread();
            }
            return value < getMin() || value > getMax() ? threshold : value;
        } finally {
            lock.readLock().unlock();
        }
    }
}
