package ai.xng;

import java.io.Serializable;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import lombok.Getter;

import java.util.Random;

/**
 * A 1-dimensional mini RL unit meant for learning the threshold that should
 * serve as a coefficient for synapse connections.
 * 
 * This is roughly a 3-bin histogram fitted to an asymmetric normal
 * distribution. The tail bins start roughly 1 "standard deviation" away (each
 * side has its own "standard deviation"), and their relative weights roughly
 * determine the skew of the distribution. The mean of the generated values is
 * the threshold, which is maintained by lengthening the tail proportionally on
 * the less probable side.
 * 
 * These properties are important because:
 * <ul>
 * <li>The weighted average of samples added to this distribution should
 * estimate a parameter value.
 * <li>Adding samples on either side of the parameter should increase
 * exploration on that side of the parameter.
 * <li>All things equal, the samples generated by this distribution should not
 * themselves cause the threshold to migrate without external variation of
 * weights. (This goal is acheived by ensuring the threshold is the mean.)
 * <li>Lastly, all things equal, this distribution should converge as it adds
 * its own samples, barring external variation of weights or samples.
 * </ul>
 * 
 * To facilitate processing optimization, the tails are truncated.
 */
public class ThresholdDistribution implements Distribution, Serializable {
    private static final long serialVersionUID = -2101048901598646069L;
    /** Number of "standard deviations" to include on each side. */
    public static final float TRUNCATE_BEYOND = 3;
    public static final float BASE_SPREAD = .0001f, NEGATIVE_WEIGHT_SPREAD = .1f, DEFAULT_WEIGHT = 1;

    private final Random random;
    @Getter
    private float threshold, covariance, weight;
    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);

    @Override
    public String toString() {
        lock.readLock().lock();
        try {
            return String.format("%.4g x [%.4g-%.4g] (%.4f / %.4f)", threshold, threshold - getLeftSpread(),
                    threshold + getRightSpread(), covariance * weight, weight);
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float getMode() {
        return threshold;
    }

    public ThresholdDistribution() {
        this(0);
    }

    public ThresholdDistribution(final float threshold) {
        this(new Random(), threshold);
    }

    public ThresholdDistribution(final Random random, final float threshold) {
        this.random = random;
        set(threshold);
    }

    @Override
    public void set(final float value) {
        lock.writeLock().lock();
        try {
            threshold = value;
            covariance = 1;
            weight = DEFAULT_WEIGHT;
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * The rough half-spread of this curve. This spread is allocated to each side
     * based on the bias.
     */
    public float getSpread() {
        lock.readLock().lock();
        try {
            return BASE_SPREAD * Math.max(1, weight) * (1 - Math.abs(covariance))
                    * (1 + NEGATIVE_WEIGHT_SPREAD * Math.max(0, -weight));
        } finally {
            lock.readLock().unlock();
        }
    }

    public float getLeftSpread() {
        lock.readLock().lock();
        try {
            return getSpread() * (1 + covariance) / 2;
        } finally {
            lock.readLock().unlock();
        }
    }

    public float getRightSpread() {
        lock.readLock().lock();
        try {
            return getSpread() * (1 - covariance) / 2;
        } finally {
            lock.readLock().unlock();
        }
    }

    private float asymmetricNormal(final float value, final float standardDeviation) {
        if (standardDeviation == 0) {
            return value == threshold ? 1 : 0;
        } else {
            final float x = (value - threshold) / standardDeviation;
            return (float) Math.exp(-x * x / 2);
        }
    }

    private float relPdf(final float value) {
        final float leftSpread = getLeftSpread(), rightSpread = getRightSpread();
        final float raw = asymmetricNormal(value, value < threshold ? leftSpread : rightSpread);
        if (value > threshold && leftSpread < rightSpread) {
            return raw * leftSpread / rightSpread;
        } else if (value < threshold && leftSpread > rightSpread) {
            return raw * rightSpread / leftSpread;
        } else {
            return raw;
        }
    }

    @Override
    public void add(final float value, final float weight) {
        if (weight == 0)
            return;

        lock.writeLock().lock();
        try {
            final float covInertia = Math.max(1, this.weight);
            final float dm = weight * (value - threshold);
            final float moment = covariance * covInertia + dm;
            covariance = moment / (covInertia + Math.abs(dm));

            final float inertia = Math.max(this.weight, -2 * weight);

            if (weight < 0) {
                covariance *= inertia / (inertia - weight);
            }

            final float dw = relPdf(value) * weight;
            threshold = (inertia * threshold + dw * value) / (inertia + dw);
            this.weight += dw;
        } finally {
            lock.writeLock().unlock();
        }
    }

    @Override
    public float getMin() {
        lock.readLock().lock();
        try {
            return threshold - getLeftSpread() * TRUNCATE_BEYOND;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float getMax() {
        lock.readLock().lock();
        try {
            return threshold + getRightSpread() * TRUNCATE_BEYOND;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float generate() {
        lock.readLock().lock();
        try {
            float value;
            if (random.nextFloat() >= (covariance + 1) / 2) {
                value = threshold - (float) Math.abs(random.nextGaussian()) * getLeftSpread();
            } else {
                value = threshold + (float) Math.abs(random.nextGaussian()) * getRightSpread();
            }
            return value < getMin() || value > getMax() ? threshold : value;
        } finally {
            lock.readLock().unlock();
        }
    }
}
