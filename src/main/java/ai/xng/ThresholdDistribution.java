package ai.xng;

import java.io.Serializable;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

import lombok.Getter;

import java.util.Random;

/**
 * A 1-dimensional mini RL unit meant for learning the threshold that should
 * serve as a coefficient for synapse connections.
 * 
 * This is roughly a 3-bin histogram fitted to an asymmetric normal
 * distribution. The tail bins start roughly 1 "standard deviation" away (each
 * side has its own "standard deviation"), and their relative weights roughly
 * determine the skew of the distribution. The mean of the generated values is
 * the threshold, which is maintained by lengthening the tail proportionally on
 * the less probable side.
 * 
 * These properties are important because:
 * <ul>
 * <li>The weighted average of samples added to this distribution should
 * estimate a parameter value.
 * <li>Adding samples on either side of the parameter should increase
 * exploration on that side of the parameter.
 * <li>All things equal, the samples generated by this distribution should not
 * themselves cause the threshold to migrate without external variation of
 * weights. (This goal is acheived by ensuring the threshold is the mean.)
 * <li>Lastly, all things equal, this distribution should converge as it adds
 * its own samples, barring external variation of weights or samples.
 * </ul>
 * 
 * To facilitate processing optimization, the tails are truncated.
 */
public class ThresholdDistribution implements Distribution, Serializable {
    private static final long serialVersionUID = -2101048901598646069L;
    /** Number of "standard deviations" to include on each side. */
    public static final float TRUNCATE_BEYOND = 3;
    public static final float BASE_SPREAD = .2f, POSITIVE_WEIGHT_SPREAD = .1f, NEGATIVE_WEIGHT_SPREAD = .5f,
            DEFAULT_WEIGHT = 10;

    private final Random random;
    @Getter
    private float threshold, covariance, weight;
    private final ReadWriteLock lock = new ReentrantReadWriteLock(false);

    @Override
    public String toString() {
        lock.readLock().lock();
        try {
            return String.format("%.4g x [%.4g-%.4g] (%.4f x %.4f)", threshold, threshold - getLeftSpread(),
                    threshold + getRightSpread(), weight, covariance);
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float getMode() {
        return threshold;
    }

    public ThresholdDistribution() {
        this(0);
    }

    public ThresholdDistribution(final float threshold) {
        this(new Random(), threshold);
    }

    public ThresholdDistribution(final Random random, final float threshold) {
        this.random = random;
        set(threshold);
    }

    @Override
    public void set(final float value) {
        lock.writeLock().lock();
        try {
            threshold = value;
            covariance = 1;
            weight = DEFAULT_WEIGHT;
        } finally {
            lock.writeLock().unlock();
        }
    }

    /**
     * The rough half-spread of this curve. This spread is allocated to each side
     * based on the bias.
     */
    public float getSpread() {
        lock.readLock().lock();
        try {
            return BASE_SPREAD * (float) Math.sqrt(1 - Math.abs(covariance))
                    * (1 + Math.max(0, NEGATIVE_WEIGHT_SPREAD * -weight))
                    / (1 + Math.max(0, POSITIVE_WEIGHT_SPREAD * weight));
        } finally {
            lock.readLock().unlock();
        }
    }

    public float getLeftSpread() {
        lock.readLock().lock();
        try {
            return getSpread() * (1 + covariance) / 2;
        } finally {
            lock.readLock().unlock();
        }
    }

    public float getRightSpread() {
        lock.readLock().lock();
        try {
            return getSpread() * (1 - covariance) / 2;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public void add(final float value, final float weight) {
        if (weight == 0)
            return;

        lock.writeLock().lock();
        try {
            float inertia = Math.max(1, getWeight());

            if (weight < DEFAULT_WEIGHT - inertia) {
                inertia = DEFAULT_WEIGHT - weight;
            }

            covariance = (inertia * covariance + weight * stableSign(value - threshold)) / (inertia + Math.abs(weight));
            threshold = (inertia * threshold + weight * value) / (inertia + weight);

            this.weight += weight * stableSign(value - threshold) * covariance;
        } finally {
            lock.writeLock().unlock();
        }
    }

    private float stableSign(float x) {
        return x > 0 ? 1 : x < 0 ? -1 : covarianceSign();
    }

    private float covarianceSign() {
        return covariance > 0 ? 1 : covariance < 0 ? -1 : 0;
    }

    @Override
    public float getMin() {
        lock.readLock().lock();
        try {
            return threshold - getLeftSpread() * TRUNCATE_BEYOND;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float getMax() {
        lock.readLock().lock();
        try {
            return threshold + getRightSpread() * TRUNCATE_BEYOND;
        } finally {
            lock.readLock().unlock();
        }
    }

    @Override
    public float generate() {
        lock.readLock().lock();
        try {
            float value;
            if (random.nextFloat() >= (covariance + 1) / 2) {
                value = threshold - (float) Math.abs(random.nextGaussian()) * getLeftSpread();
            } else {
                value = threshold + (float) Math.abs(random.nextGaussian()) * getRightSpread();
            }
            return value < getMin() || value > getMax() ? threshold : value;
        } finally {
            lock.readLock().unlock();
        }
    }
}
